#!/bin/sh
# ------------------------------------------------------------------------------------------
#	 Вспомогательные переменные для работы скрипта
# ------------------------------------------------------------------------------------------
RED="\033[1;31m";
GREEN="\033[1;32m";
BLUE="\033[36m";
YELLOW="\033[33m";
NOCL="\033[m";

LENGTH=66
PROGRESS_BAR_WIDTH=$((LENGTH-5))  # progress bar length in characters

# ------------------------------------------------------------------------------------------
#
# 		Прогресс-бар
# 		Источник:
# 		https://stackoverflow.com/questions/238073/how-to-add-a-progress-bar-to-a-shell-script
#
# ------------------------------------------------------------------------------------------

progress_bar() {
  # Аргументы: текущее значение, максимальное значение, единица измерения (необязательно)
  value=${1}
  max=${2}
  unit=${3:-""}  # если блок не указан, не отображаем его
  [ -n "${unit}" ] && unit=" ${unit}"
  # Calculate percentage
  if [ "${max}" -lt 1 ]; then max=1; fi  # защита от деления на ноль
  percentage=$(( 100 - (max*100 - value*100) / max))

  # Меняем масштаб полосы в соответствии с шириной индикатора выполнения.
  num_bar=$(( percentage * PROGRESS_BAR_WIDTH / 100 ))

  # Рисуем прогресс-бар
  printf " [ ${GREEN}"
  for b in $(seq 1 ${num_bar}); do printf "#"; done
  for s in $(seq 1 $(( PROGRESS_BAR_WIDTH - num_bar ))); do printf " "; done
  printf "${NOCL} ] ${percentage}%% (${value}/${max}${unit})\r"
}


# ------------------------------------------------------------------------------------------
#
#	Форматирует разряды числа, разделяя их пробелом: 122 543 567
#
# ------------------------------------------------------------------------------------------

dig_frm(){
	echo "${1}" | sed ':a;s/\([^0-9.][0-9]\+\|^[0-9]\+\)\([0-9]\{3\}\)/\1\ \2/g;ta'
}
# ------------------------------------------------------------------------------------------
#
#	Получаем локальный IP роутера
#
# ------------------------------------------------------------------------------------------
get_router_host(){
	port=$(curl -s "localhost:79/rci/ip/http/port" | tr -d '" ')
	ip=$(ip a | grep ": br0:" -A4 | grep 'inet ' | tr -s ' ' | cut -d' ' -f3 | cut -d'/' -f1)
	ssl=$(curl -s "localhost:79/rci/ip/http/security-level" | grep ssl | sed 's/.ssl.://' | tr -d " ")
	[ "${ssl}" = "true" ] && protocol='https://' || protocol='http://'
	! [ "${port}" -eq 80 ] && ip="${ip}:${port}"
	echo "${protocol}${ip}"
}
# ------------------------------------------------------------------------------------------
#
#	Печать текста с выравниванием по левому краю
# 	$1 - текст
#	$2 - ширина выравнивания в символах
#
# ------------------------------------------------------------------------------------------
ljust() {
  printf "%-${2}s" "${1}"
}
# ------------------------------------------------------------------------------------------
#
#	 Вспомогательная функция печати в лог отладки
#
# ------------------------------------------------------------------------------------------
echo_debug(){
  if [ -n "${2}" ]; then
    print_line; echo -e "${1}"; print_line
    echo -e "${2}"; printf "\n"
  fi
}
diff_len(){
	charlen=$(echo "${1}" | sed -r "s/[\]033\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g")
	charlen=${#charlen}
	echo $(( LENGTH - charlen ))
}
ready() {
	size=$(diff_len "${1}")
	printf "%b%-${size}s%b" "${1}"
}
error(){
	_error="${RED}${1}${NOCL}"
	size=$(diff_len "${_error}")
	printf "%b%-${size}s%b\n" "${_error}"
}
warning(){
	_error="${GREEN}${1}${NOCL}"
	size=$(diff_len "${_error}")
	printf "%b%-${size}s%b\n" "${_error}"
}

when_ok(){
  echo -e "${GREEN}${1}${NOCL}"
}
when_bad(){
  echo -e "${RED}${1}${NOCL}"
}

#функция перчатает заданное число раз один и тот же символ
print_line() {
	len=$((LENGTH + 12))
	printf "%${len}s\n" | tr " " "-"
}
please_repeat(){
  echo -e "Пожалуйста ответьте на вопрос ${GREEN}'Y' - да${NOCL} или ${RED}'N' - нет${NOCL}, ${BLUE}Q - выход${NOCL}"
}

clear_file(){
  cat < "${1}" | sed 's/\(^.*\)#.*$/\1/g' | grep -v '#' | sed "/^$/d" | sed 's/^\.//g'
}

clear_content(){
	if [ -f "${1}" ] && [ -n "${2}" ]; then
		clear_file "${1}" | sort | uniq | grep "^${2}"
	else
	  clear_file "${1}" | sort | uniq
	fi
}
clear_file_content(){
	content=$(clear_content "${1}")
	echo "${content}" > "${1}"
}

rec_in_file(){
  if [ "${2}" ]; then
	  clear_content "${1}" | grep -c "^${2}"
	else
	  clear_content "${1}" | wc -l
	fi
}
# ------------------------------------------------------------------------------------------
#
#	 Читаем Y/N/Q из ввода данных в цикле
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#
# ------------------------------------------------------------------------------------------
read_ynq(){
	header="${1}"
	while true; do
		ready "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=${ynq}"; break; ;;
			[Nn]* ) eval "${2}=${ynq}"; break; ;;
			[Qq]* ) eval "${2}=${ynq}"; ;;
			     *) please_repeat ;;
		esac
	done
}

# ------------------------------------------------------------------------------------------
#
#	 Читаем значение переменной из ввода данных в цикле
#	 $1 - заголовок для запроса
#	 $2 - переменная в которой возвращается результат
#	 $3 - тип вводимого значения
#		 digit - цифра
#		 password - пароль без показа вводимых символов
#
# ------------------------------------------------------------------------------------------
read_value(){
        header="${1}"
        type="${3}"

        while true; do
                ready "${header}"
                if [ "${type}" = 'password' ]; then read -rs value; else read -r value; fi
                if [ -z "${value}" ]; then
                        echo
                        print_line
                        echo -e "${RED}Данные не должны быть пустыми!"
                        echo -e "${GREEN}Попробуйте ввести значение снова...${NOCL}"
                        print_line
                elif [ -n "$(echo "${value}" | grep -iE '^Q$')" ]; then
                        value=''
                        break
                elif [[ "${type}" = 'digit' ]] && [[ -z "$(echo "${value}" | grep -E '^[[:digit:]]{1,6}$')" ]]; then
                        echo
                        print_line
                        echo -e "${RED}Введенные данные должны быть цифрами!"
                        echo -e "${GREEN}Попробуйте ввести значение снова...${NOCL}"
                        print_line
                elif [[ "${type}" = 'password' ]] && [[ -z "$(echo "${value}" | grep -E '^[[:graph:]]{8,1024}$')" ]]; then
                        echo
                        print_line
                        echo -e "${GREEN}Пароль должен содержать минимум 8 знаков."
                        echo -e "${RED}Попробуйте ввести его снова...${NOCL}"
                        print_line
                else
                        eval "${2}=${value}"
                        break
                fi
        done
}
# ------------------------------------------------------------------------------------------
#
#	 Обновляем системное время
#
# ------------------------------------------------------------------------------------------
date_update(){
	curdate=$(date)
	date -u -D '%a, %d %b %Y %H:%M:%S' -s "$(curl --insecure --silent --max-time 5 --head 'https://1.1.1.1/' 2>/dev/null | grep -i ^Date: | cut -d' ' -f2-)" &>/dev/null
	if [ "$?" != "0" ]; then
		date -u -D '%a, %d %b %Y %H:%M:%S' -s "$(curl --insecure --silent --max-time 5 --head 'https://9.9.9.9/' 2>/dev/null | grep -i ^Date: | cut -d' ' -f2-)" &>/dev/null
		if [ "$?" = "0" ]; then
			echo "Системное время успешно обновлено с резервного сервера:"
			echo "${curdate} -> $(date)"
		fi
	else
		echo "Системное время успешно обновлено с основного сервера:"
		echo "${curdate} -> $(date)"
	fi
}