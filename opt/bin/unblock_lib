#!/bin/sh
# ------------------------------------------------------------------------------------------
#	 Вспомогательные переменные для работы скрипта
# ------------------------------------------------------------------------------------------
RED="\033[1;31m";
GREEN="\033[1;32m";
BLUE="\033[36m";
YELLOW="\033[33m";
NOCL="\033[m";

LENGTH=66

ljust() {
  printf "%-24s" "${1}"
}
# ------------------------------------------------------------------------------------------
#
#	 Вспомогательная функция печати в лог отладки
#
# ------------------------------------------------------------------------------------------
echo_debug(){
  if [ -n "${2}" ]; then
    print_line; echo "${1}"; print_line
    echo "${2}"; printf "\n"
  fi
}
diff_len(){
	charlen=$(echo "${1}" | sed -r "s/[\]033\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g")
	charlen=${#charlen}
	echo $(( LENGTH - charlen ))
}
ready() {
	size=$(diff_len "${1}")
	printf "%b%-${size}s%b" "${1}"
}
error(){
	_error="${RED}${1}${NOCL}"
	size=$(diff_len "${_error}")
	printf "%b%-${size}s%b\n" "${_error}"
}
warning(){
	_error="${GREEN}${1}${NOCL}"
	size=$(diff_len "${_error}")
	printf "%b%-${size}s%b\n" "${_error}"
}

when_ok(){
  echo -e "${GREEN}${1}${NOCL}"
}
when_bad(){
  echo -e "${RED}${1}${NOCL}"
}

#функция перчатает заданное число раз один и тот же символ
print_line() {
	len=$((LENGTH + 12))
	printf "%${len}s\n" | tr " " "-"
}
please_repeat(){
  printf "%s" "Пожалуйста ответьте на вопрос ${GREEN}'Y'- да${NOCL} или ${RED}'N'- нет.${NOCL}\n"
}

clear_file(){
  cat < "${1}" | sed 's/\(^.*\)#.*$/\1/g' | grep -v '#' | sed "/^$/d"
}

clear_content(){
	if [ -f "${1}" ] && [ -n "${2}" ]; then
		clear_file "${1}" | sort | uniq | grep "^${2}"
	else
	  clear_file "${1}" | sort | uniq
	fi
}
clear_file_content(){
	content=$(clear_content "${1}")
	echo "${content}" > "${1}"
}

rec_in_file(){
  if [ "${2}" ]; then
	  clear_content "${1}" | grep -c "^${2}"
	else
	  clear_content "${1}" | wc -l
	fi
}
# Прогресс-бар
# Источник https://stackoverflow.com/questions/238073/how-to-add-a-progress-bar-to-a-shell-script
#
PROGRESS_BAR_WIDTH=$((LENGTH-10))  # progress bar length in characters
progress_bar() {
  # Arguments: current value, max value, unit of measurement (optional)
  value=${1}
  max=${2}
  unit=${3:-""}  # if unit is not supplied, do not display it

  # Calculate percentage
  if [ "${max}" -lt 1 ]; then max=1; fi  # anti zero division protection
  percentage=$(( 100 - (max*100 - value*100) / max))

  # Rescale the bar according to the progress bar width
  num_bar=$(( percentage * PROGRESS_BAR_WIDTH / 100 ))

  # Draw progress bar
  printf "["
  for b in $(seq 1 ${num_bar}); do printf "#"; done
  for s in $(seq 1 $(( PROGRESS_BAR_WIDTH - num_bar ))); do printf " "; done
  printf "] ${percentage}%% (${value}/${max} ${unit})\r"
}

